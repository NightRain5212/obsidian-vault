
## 定义

- 拓扑排序是针对**有向无环图（DAG, Directed Acyclic Graph）**的线性排序，使得对于图中的每一条有向边 `(u, v)`，`u` 在排序中总是位于 `v` 的前面。  
- 换句话说，拓扑排序反映了图中节点的依赖关系。
- 如果图中存在环，则无法完成拓扑排序。

## Kahn算法

- 通过不断删除图中**入度为 0 的节点**，若最终能删除所有节点，则存在拓扑排序；否则存在环。

- **计算所有节点的入度**（指向该节点的边数）。
- **将入度为 0 的节点加入队列**。
- **依次取出队列中的节点**：
    - 删除该节点的所有出边（邻接节点入度减 1）。
    - 若某邻接节点的入度变为 0，则加入队列。
 - **判断结果**：
    - 若所有节点被删除（排序结果长度 = 节点数），则存在拓扑排序。
    - 否则，存在环。

```cpp
queue<int> q;
vector<int> path;
void tpsort() {
    while(!q.empty())
    {
        int c = q.front(); q.pop();
        path.push_back(c);
        for(int u:g[c]) {
            id[u]--;
            if(id[u]==0) q.push(u);
        }
    }
}
```


##### **复杂度分析**

- 时间复杂度：$O(V+E)$（遍历所有节点和边）。
- 空间复杂度：$O(V)$（存储入度和队列）。

## 拓补排序解决任务调度问题


- 计算每个任务的**最早开始时间**和**最迟开始时间**
```cpp
void getearly()
{
    for(int i:path)
    {
        for(auto p:g[i]) {
            int v=p.first;int time=p.second;
            early[v] = max(early[v],early[i]+time);
        }
    }
}

void getlate()
{
    for(int i=1;i<=n;i++) {
        late[i]=totaltime;
    }
    for(int i=path.size()-1;i>=0;i--)
    {
        int cur = path[i];
        for(auto p:g[cur]) {
            int v=p.first;int time=p.second;
            late[cur] = min(late[cur],late[v]-time);
        }
    }
}
```
- 如果一个任务的**最早开始时间**和**最迟开始时间**相同则是关键任务，**无法延迟进行**