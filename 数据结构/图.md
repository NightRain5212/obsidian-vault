
## 定义

- 图G由两个集合组成，分别为顶点集V和边集E.
$$G=(V,E)$$
- **有向图**：$<v_1,v_2>,<v_2,v_1>$为不同的边，即存在一定方向。
	- $<v_1,v_2>$，$v_1$邻接到$v_2$
	- **入度**：射入顶点的边的条数
	- **出度**：射出顶点的边的条数
	- **完全有向图**：每对顶点都有互相到达的边
	- **强连通**：任意两个节点之间连通
	- **弱连通**：有向图对应的无向图连通
	- **强连通分量**：极大强连通子图
	- **弱连通分量**：极大若连通子图
- **无向图**：$<v_1,v_2>,<v_2,v_1>$不做区分。
	- 记作$(v_1,v_2)$,$v_1,v_2$相邻接。
	- **度**： 无向图中，一个顶点的度就是与其邻接的顶点个数。
	- **完全无向图**：每对顶点都有一条边。
	- **连通**：每个顶点之间都存在路径
	- **连通分量**：图的极大连通子图
- **路径**：
	- 从顶点v到顶点w,可由一个顶点序列表示，路径长度即为顶点序列个数减一，即边的个数

## 存储结构

### 邻接矩阵


```cpp
int G[N][N];
```
- 共有N个顶点，用二维数组存储边，若存在顶点i到顶点j的边，则`G[i][j]=1`
- 若是带权图，则`G[i][j]=w`
- 若是无向图，则`G[i][j]=G[j][i]`,即对称矩阵

### 邻接表

- 建立二维的线性表，一维存储节点编号，定义为存储该节点的邻接节点。
```cpp
vector<int> G[N];
```
- 带权图
```cpp
struct Node {
	int id;
	int weight;
};
vector<Node> G[N];

//或者
vector<pair<int,int>> G[N];
```

## 图的遍历

 
### 深度优先搜索

- 一条路走到黑，走不通再回头找其他路
```cpp
vector<int> g[N];
bool vis[N];
void dfs(int s) {
	if(vis[s]) return;
	visit(s);
	vis[s]=1;
	for(int u:g[s]) {
		dfs(u);
	}
}
```

### 广度优先搜索

- 呈辐射状从起点扩散
```cpp
vector<int> g[N];
bool vis[N];
void bfs(int s) {
	queue<int> q;
	q.push(s);
	vis[s]=1;
	while(!q.empty()) {
		int cur = q.front();
		q.pop();
		visit(cur);
		for(int u:g[s]) {
			if(vis[u]) continue;
			q.push(u);
			vis[u]=1;
		}
	}
}
```


### 最小生成树

- 见[[最小生成树]]

## 最短路径

- 见[[最短路径]]

## 拓补排序

- 见[[拓补排序]]

## 关键路径

- 见[[关键路径]]