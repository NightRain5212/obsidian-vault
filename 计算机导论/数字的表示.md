---
title: 计算机中数字的表示
description: 计算机导论期末复习~
categories:
  - study
  - python
tags:
  - python
  - 计算机导论
---
### 进制

|    进制     | 基数  | 进位原则  |  基本符号   |
| :-------: | :-: | :---: | :-----: |
| 二进制(Bin)  |  2  | 逢2进1  |   0,1   |
| 八进制(Oct)  |  8  | 逢8进1  |   0~7   |
| 十进制(Dec)  | 10  | 逢10进1 |   0~9   |
| 十六进制(Hex) | 16  | 逢16进1 | 0~9,A~F |

- 如果某一个进制采用$R$个基本符号，则称$R$为**基数**（二进制基数为2，十进制基数为10）。进制中每一位单位值称为**位权**，在整数部分第$i$位的位权为$R^{i}$（个位为第0位），小数点右边第$j$位的位权为$R^{-j}$
- 如$12.34_{10}=1\times 10^1+2\times 10^0 + 3\times 10^{-1}+4\times10^{-2}$
- 在二进制里，二进制的一位为1bit（1b），连续的8bits为一字节(byte)（1B）
	- 即，$1B=8b$
- R进制下的每一位数的范围为:$0 \le a_i \le R-1$

### 不同进制的转化

#### 二进制转十进制

- 直接用每一位上的数乘以其对应的位权，再对每一位的结果求和即可得到十进制值。
- 如：$1011_{2} = 1\times 2^3+0\times 2^2+1\times 2^1+1\times 2^0=11_{10}$

#### R进制转十进制

- 由以上公式可以推出更一般的转化十进制的方法
$$A_R=a_na_{n-1}...a_2a_1a_0$$
$$A_{10}=a_n\times R^{n} +a_{n-1}\times R^{n-1}+...+a_2\times R^2+a_1\times R^1 + a_0\times R^0$$

#### 十进制转R进制

- 整数部分--除R取余法：
	- 已知十进制数$x$，求$R$进制下的数值
	- 将$x$除以$R$，记录所得余数$r$
	- 用得到的商作为新的被除数$x$，重复上述过程，直到$x$为0
	- 最后倒序输出每次除法得到的余数
- 小数部分--乘$R$取整法：
	- 已知十进制小数的小数部分为$x$
	- 将$x$乘以$R$，取乘积的整数部分作为小数部分的第一位
	- 然后取乘积的小数部分作为新的$x$
	- 重复上述过程，直到乘积为0，或已取得对应精度的小数位数。

#### 二，八，十六进制的快速转化

- 由于$2^3=8 ，\space 2^4=16$，所以**一位八进制可以用三位二进制数**表示，**一位十六进制数可以用四位二进制数**表示，即**三位一并法**，**四位一并法**
- 注意在转化时，二进制高位不足时要补足0
- 如：$1100010_2=0110\space 0010_2=62_{16}$

| Dec | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| --- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| Bin | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 |
| Oct | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| Hex | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |

| Dec | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| --- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| Bin | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |
| Oct | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   |
| Hex | 8    | 9    | A    | B    | C    | D    | E    | F    |

### 计算机中的运算

- CPU一次只能处理**有限位数的二进制数**，如32为的CPU一次最多处理32位的二进制数。计算机的整数有两种类型：无符号整数，有符号整数
- 二进制下的加减法与十进制类似，但由于CPU一次处理的位数有限所以可能会出现两个整数相加的和超出最大能够表示的位数，此时最高位就会丢失，称为**溢出**.

#### 无符号整数的乘法与除法：

- 乘法：由基本的二进制加法和移位来完成。（类似于小学的竖式运算）
- 除法：由二进制减法和移位来完成。（类似于小学的竖式运算）

#### 有符号整数的表示法

- （以8位CPU为例）
- 8位CPU的表示范围为$[0,255]$，将区间分为两部分$[0,127],[128,255]$
- 注意到区间$[0,127]$的每个数的二进制数首位均为0；而$[128,255]$区间的每个数的二进制数首位均为1
- 计算机中，前一个区间表示正数范围$[0,127]$，后一个区间表示负数范围$[-128,-1]$。
- 这样表示是合理的，如：（CPU自动舍去超过最大位数的部分）$00000001_2(1)+11111111_2(-1)=100000000_2=00000000_2(0)$
- 对于一个正整数$x$，它的相反数$-x$所对应的无符号整数为$2^8-x$

#### 负数的补码表示法

- 一个二进制数`x`的补码为`~x+1`，即**对它的每一位取反后再加上1.**
- 正负数之间的转化可以简单地通过取补码来实现
	- 如：$11111001_2(-7)=>00000110+1=00000111_2(7)$
- 用n位补码表示有符号整数的范围为$[-2^{n-1},2^{n-1}-1]$
- 一个带符号整数的二进制值被称为真值，如$-7$的真值为$11111001_2$

#### 带符号整数的运算溢出

- 加减法的溢出：
- 两个正数相加：可能发生正溢出（相加结果的最高位数为1）		
- 如：$120+30=01111000_2+00011110_2=10010110_2(-106)$
- 一正一负相加：不可能发生溢出
- 两个负数相加：可能发生负溢出（相加结果的最高位数为0）
- 如：$-120+(-30)=10001000_2+11100010_2=101101010_2=01101010_2(106)$

### 浮点数

- 计算机中带小数点的数称为**浮点数**
- 工业上使用*IEEE754*二进制浮点数算术标准来表示浮点数。
- 一个*IEEE754*浮点数**最多用64位**来存放，所以有一定的**精度损失**

#### IEEE754标准

- 在IEEE754下，一个浮点数由三个部分组成：*符号位$s$，指数$e$，尾数$m$*。
- 即$a=\pm m\times 2^e$ 的形式
- 符号位：表示正数时为0，表示负数时为1
- 尾数：用来存储形如$1.d_1d_2...d_i...$的二进制小数的小数部分，其中$d_i \in \{0,1\}$。尾数只存储小数点后面的部分，不需要存储最前面的1。最多储存的$d_i$个数决定了表示的精度，不足的位数补足0.
- 指数：指数部分的正负**不采用补码表示**法，而是通过**中间数的偏移**来表示正负。（便于计算指数之间的差距和比较两个指数的大小）
- 如8位指数部分下：中间数为$01111111(127)$，所以用真值$127(01111111)$来表示指数部分的0；$01111110(126)$，表示指数部分的-1；$10000000(128)$表示指数部分的1，以此类推即可。
- *IEEE754-32*位浮点数的组成：1位的s+8位的e+23位的m
- *IEEE754-64*位浮点数的组成：1位的s+11位的e+52位的m
- IEEE浮点数的加减法：先移动较小数的小数点，使得两个浮点数的指数部分相同再进行加法运算。
#### 十进制小数向IEEE浮点数的转化

- 写出十进制小数对应的二进制小数。($5.625_{10}=101.101_2$)
- 对二进制小数的小数点移动进行标准化。($101.101_2=1.01101\times 2^2$)
- 标准化：将小数点移动到第一个出现的1之后，还要补上对应的2的n次幂
- 将标准化后的小数写成IEEE形式($01000000101101000000000000000000$)
- 如：5.625，即符号位0+指数10000001+尾数01101000...(23位)

### 程序实现练习

- 练习1：输入一个十进制数和n，输出对应的n位二进制补码
- 个人实现仅供参考：
```python
bits = int(input("输入二进制位数n:"))
num = int(input("输入十进制数："))

# 转二进制
def toBin(n):
    if n==0: return "0"
    if n==1: return "1"
    return toBin(n//2)+toBin(n%2)

# 格式化（将其格式化为n位二进制）
def format(n,bits=8):
    if len(n) < bits:
        d = bits - len(n)
        head = "0"*d
        return head+n
    elif len(n) > bits:
        return n[-bits:]
    return n

# 反码
def convert(n):
    str = ""
    for i in range(len(n)):
        if(n[i]=='0'):
            str += "1"
        elif(n[i]=='1'):
            str+= "0"
    return str

# 加一
def add1(n):
    l = [int(i) for i in n]
    l[len(n)-1] += 1
    for i in range(len(n)-1,0,-1):
        if l[i] > 1:
            l[i] %= 2
            l[i-1] += 1
    if l[0] == 2:
        l[0] = 0
    res = ""
    for i in l:
        res += str(i)
    return res

c = toBin(abs(num))
c = format(c,bits)

# 正数的补码就是真值本身
if num >= 0:
    print(c)
else:
    c = convert(c)
    c = add1(c)
    c = format(c,bits)
    print(c)

#输入样例:8 -7
#输出样例:11111001
```

- 练习2：
- 输入一个十进制小数，输出对应的IEEE32位浮点数，并输出其对应的十进制小数
- 个人实现的是64位IEEE,仅供参考：
```python
MSIZE = 52
ESIZE = 11
from decimal import *
getcontext().prec = 70
# 整数部分
def toBinA(string):
    i = int(string)
    if i < 2: return str(i)
    return toBinA(str(int(string)//2)) + str(int(string)%2)

# 小数部分
def toBinB(string):
    result = ""
    i = Decimal(string)
    while(len(result)<=70):
        i*=2
        result += str(int(i))
        i-=int(i)
    return result

# 指数部分
def toBinC(int):
    i = int + 1023
    return toBinA(i)

# 整数
def toDecA(bin):
    sum = 0
    for i in range(len(bin)):
        sum = sum*2 + int(bin[i])
    return sum

# 小数
def toDecB(bin):
    sum = 0
    if(int(bin)==0): return 0.0
    for i in range(len(bin)):
        sum += int(bin[i]) * (Decimal("0.5")**(i+1))
    return sum

# 指数
def toDecC(bin):
    dec = toDecA(bin)
    return dec-1023

def dec2float(string):
    string = str(float(string))
    a,b = string.split(".")[0],string.split(".")[1]
    b = "0."+b
    if Decimal(string)<0: sign = '1';a=str(abs(int(a)))
    else: sign = '0'
    # 化为二进制
    a = toBinA(a)
    b = toBinB(b)
    # 指数位
    if "1" in a:
        e = len(a) - 1
        b = a[1:] + b
        a = "1"
        e = toBinC(e)
    else:
        head1 = b.find("1")
        if(head1 == -1):
            e = '0'*ESIZE
            mantissa = '0'*MSIZE
            return sign+e+mantissa
        e = -(head1+1)
        a = "1"
        b = b[(head1+1):]
        e = toBinC(e)
    mantissa = b[:MSIZE]
    if len(mantissa)<MSIZE: mantissa+='0'*(MSIZE-len(mantissa))
    if len(e)<ESIZE: e='0'*(ESIZE-len(e)) + e 
    return sign+e+mantissa


def float2dec(string):
    sign = string[0]
    e = string[1:12]
    mantissa = string[12:]
    e = toDecC(e)
    mantissa = toDecB(mantissa)
    mantissa = Decimal("1."+str(mantissa).split(".")[1])
    num = mantissa * Decimal(2 ** e)
    if sign == "1" : return -num
    else: return num

i = input()
print(dec2float(i))
print(float2dec(dec2float(i)))



#测试样例

#>>> 3.14
#0100000000001001000111101011100001010001111010111000010100011110
#3.1399999999999996802557689079549163579940795898437500

#>>> 0
#0000000000000000000000000000000000000000000000000000000000000000
#1.112536929253600691545116358666202032109607990231165915276663708443602E-308

#>>> -5.625
#1100000000010110100000000000000000000000000000000000000000000000
#-5.6250000000000000000000000000000000000000000000000000

```

